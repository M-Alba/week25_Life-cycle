# week25_Life-cycle

Ответы на вопросы:
1. В компонент передаются атрибуты description и title. Могу ли я их сложить как на примере, чтобы получить одну строку и вывести в компоненте?

import React from "react";
import styles from './button.css'

export default class Example extends React.Component {
    render() {
		let {description,title} = this.props
		title += description; //title = title + description
         		return (
           			 <span>{title}</span>
        		);
    	}
}

Нет.

2. С помощью какого метода можно отловить изменение props? 
ShouldComponentUpdate() 

3. Оператор расширения часто используется также для клонирования объекта. Подумайте, чем отличаются эти две записи и какую проблему решает здесь оператор расширения:

const initialObj = { title: 'Hello', text: 'World' };
const firstObj =  initialObj;
//в данном случае изменения, внесенные в новый массив, повлекут изменения также в существующем массиве.

const secondObj =  {...initialObj};
//если клонировать существующий массив, используя оператор расширения, то изменения, внесенные в новый массив, не повлияют на существующий массив.

4. В каком из методов жизненного цикла лучше всего использовать методы вызова API и обращения к веб-хранилищам, если они должны быть вызваны всего один раз при загрузке страницы? 
ComponentDidMount()

5. С помощью какого метода можно отловить и отрисовать для пользователя возникшую в компоненте ошибку? 
ComponentDidCatch()

6. Какой код обычно пишут в конструкторе? Для каких задач он используется?

Конструкторы в React обычно используют для двух целей:
    • инициализация внутреннего состояния через присвоение объекта this.state ; 
    • привязка обработчиков событий к экземпляру. 
 
class Counter extends Component {
	constructor(props) {
		super(props);
		this.state = { counter: 0 };
		this.handleClick = this.handleClick.bind(this);
	}
	
    handleClick() {
		// ...
    }
}


7. Что делает функция render()? Что может её вызвать? 
Метод render определяет, что должно быть отображено на экране в ответ на изменение состояния или свойств компонента. Он вызывается автоматически, когда компонент монтируется или обновляется 

8. Что нужно изменить в коде из урока (видео), чтобы начальные параметры у компонента приходили из пропсов, но если пропсы вообще не заданы, начальные значения были инициализированы нулями?

Может я не поняла вопрос, а что изменить, если в видео было так:
constructor(props)
    {
        super(props);
        this.state = {
            minutes: 0,
            seconds: 0
        }
    }


9. Можно ли несколько раз использовать хук useEffect внутри одного компонента? 
Да.

10. Можно ли не передавать второй аргумент в хук useEffect? Что тогда произойдёт? 
Можно. Если не передать второй аргумент в хук UseEffect, то колбэк, переданный в useEffect(), будет отрабатывать после первой отрисовки и каждого обновления компонента. 

11. Что означает возвращение функции в теле хука useEffect? 
Сброс эффекта.

12. Будут ли перерисованы дочерние элементы компонента при вызове метода forceUpdate()?
Да.


